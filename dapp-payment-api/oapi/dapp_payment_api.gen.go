// Package oapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package oapi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

const (
	MerchantAPIKeyScopes = "merchantAPIKey.Scopes"
)

// Merchant defines model for Merchant.
type Merchant struct {
	MerchantCode   string                  `json:"merchantCode"`
	MerchantID     int64                   `json:"merchantID"`
	MerchantName   string                  `json:"merchantName"`
	TagDescription *string                 `json:"tagDescription,omitempty"`
	TagDisplayName *map[string]interface{} `json:"tagDisplayName,omitempty"`
	Wallets        *[]MerchantWallet       `json:"wallets,omitempty"`
}

// MerchantQueryReply defines model for MerchantQueryReply.
type MerchantQueryReply struct {
	Data []MerchantTransaction `json:"data"`
	Meta struct {
		HasNext   bool   `json:"hasNext"`
		NextSeqNo *int64 `json:"nextSeqNo"`
	} `json:"meta"`
}

// MerchantTransaction defines model for MerchantTransaction.
type MerchantTransaction struct {
	Amount        string `json:"amount"`
	BlockHash     string `json:"blockHash"`
	BlockNo       int64  `json:"blockNo"`
	ConfirmStatus int    `json:"confirmStatus"`
	NetworkCode   string `json:"networkCode"`
	OnchainStatus int    `json:"onchainStatus"`
	SeqNo         int64  `json:"seqNo"`
	Symbol        string `json:"symbol"`
	Tag           string `json:"tag"`
	TxHash        string `json:"txHash"`
}

// MerchantWallet defines model for MerchantWallet.
type MerchantWallet struct {
	Address     string `json:"address"`
	NetworkCode string `json:"networkCode"`
	Symbol      string `json:"symbol"`
}

// Network defines model for Network.
type Network struct {
	ChainID     *int   `json:"chainID"`
	NetworkCode string `json:"networkCode"`
	NetworkID   int64  `json:"networkID"`
	NetworkName string `json:"networkName"`
}

// Submission defines model for Submission.
type Submission struct {
	Amount    string `json:"amount"`
	Coin      string `json:"coin"`
	From      string `json:"from"`
	Merchant  string `json:"merchant"`
	Signature string `json:"signature"`
	Tag       string `json:"tag"`
}

// SubmissionReply defines model for SubmissionReply.
type SubmissionReply struct {
	Amount        string    `json:"amount"`
	FromAddress   string    `json:"fromAddress"`
	NetworkCode   string    `json:"networkCode"`
	PaymentStatus int       `json:"paymentStatus"`
	SubmitTime    time.Time `json:"submitTime"`
	Symbol        string    `json:"symbol"`
	TxHash        string    `json:"txHash"`
	TxStatus      int       `json:"txStatus"`
}

// Token defines model for Token.
type Token struct {
	Address     string `json:"address"`
	Decimals    int    `json:"decimals"`
	Name        string `json:"name"`
	NetworkCode string `json:"networkCode"`
	Symbol      string `json:"symbol"`
	TokenID     int64  `json:"tokenID"`
}

// GetTransactionsByMerchantParams defines parameters for GetTransactionsByMerchant.
type GetTransactionsByMerchantParams struct {
	StartingSeqNo int64 `json:"startingSeqNo"`
	Limit         *int  `json:"limit,omitempty"`
}

// SubmitPaymentTransactionJSONBody defines parameters for SubmitPaymentTransaction.
type SubmitPaymentTransactionJSONBody Submission

// SubmitPaymentTransactionJSONRequestBody defines body for SubmitPaymentTransaction for application/json ContentType.
type SubmitPaymentTransactionJSONRequestBody SubmitPaymentTransactionJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get List of Merchants
	// (GET /merchants)
	GetAllMerchants(w http.ResponseWriter, r *http.Request)
	// Get Detailed Merchant Information
	// (GET /merchants/{merchantCode})
	GetMerchant(w http.ResponseWriter, r *http.Request, merchantCode string)
	// Get transactions by merchant
	// (GET /merchants/{merchantCode}/transactions)
	GetTransactionsByMerchant(w http.ResponseWriter, r *http.Request, merchantCode string, params GetTransactionsByMerchantParams)
	// Get All Networks
	// (GET /networks)
	GetAllNetworks(w http.ResponseWriter, r *http.Request)
	// Get All Tokens
	// (GET /networks/{networkCode}/tokens)
	GetAllTokens(w http.ResponseWriter, r *http.Request, networkCode string)
	// Get Submission Status of a Payment Transaction
	// (GET /networks/{networkCode}/transactions/{txHash})
	GetSubmission(w http.ResponseWriter, r *http.Request, networkCode string, txHash string)
	// Submit Payment Information of Transaction
	// (POST /networks/{networkCode}/transactions/{txHash})
	SubmitPaymentTransaction(w http.ResponseWriter, r *http.Request, networkCode string, txHash string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// GetAllMerchants operation middleware
func (siw *ServerInterfaceWrapper) GetAllMerchants(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAllMerchants(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetMerchant operation middleware
func (siw *ServerInterfaceWrapper) GetMerchant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "merchantCode" -------------
	var merchantCode string

	err = runtime.BindStyledParameter("simple", false, "merchantCode", chi.URLParam(r, "merchantCode"), &merchantCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "merchantCode", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMerchant(w, r, merchantCode)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTransactionsByMerchant operation middleware
func (siw *ServerInterfaceWrapper) GetTransactionsByMerchant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "merchantCode" -------------
	var merchantCode string

	err = runtime.BindStyledParameter("simple", false, "merchantCode", chi.URLParam(r, "merchantCode"), &merchantCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "merchantCode", Err: err})
		return
	}

	ctx = context.WithValue(ctx, MerchantAPIKeyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionsByMerchantParams

	// ------------- Required query parameter "startingSeqNo" -------------
	if paramValue := r.URL.Query().Get("startingSeqNo"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "startingSeqNo"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "startingSeqNo", r.URL.Query(), &params.StartingSeqNo)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "startingSeqNo", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTransactionsByMerchant(w, r, merchantCode, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetAllNetworks operation middleware
func (siw *ServerInterfaceWrapper) GetAllNetworks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAllNetworks(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetAllTokens operation middleware
func (siw *ServerInterfaceWrapper) GetAllTokens(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "networkCode" -------------
	var networkCode string

	err = runtime.BindStyledParameter("simple", false, "networkCode", chi.URLParam(r, "networkCode"), &networkCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "networkCode", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAllTokens(w, r, networkCode)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetSubmission operation middleware
func (siw *ServerInterfaceWrapper) GetSubmission(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "networkCode" -------------
	var networkCode string

	err = runtime.BindStyledParameter("simple", false, "networkCode", chi.URLParam(r, "networkCode"), &networkCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "networkCode", Err: err})
		return
	}

	// ------------- Path parameter "txHash" -------------
	var txHash string

	err = runtime.BindStyledParameter("simple", false, "txHash", chi.URLParam(r, "txHash"), &txHash)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "txHash", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSubmission(w, r, networkCode, txHash)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SubmitPaymentTransaction operation middleware
func (siw *ServerInterfaceWrapper) SubmitPaymentTransaction(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "networkCode" -------------
	var networkCode string

	err = runtime.BindStyledParameter("simple", false, "networkCode", chi.URLParam(r, "networkCode"), &networkCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "networkCode", Err: err})
		return
	}

	// ------------- Path parameter "txHash" -------------
	var txHash string

	err = runtime.BindStyledParameter("simple", false, "txHash", chi.URLParam(r, "txHash"), &txHash)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "txHash", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SubmitPaymentTransaction(w, r, networkCode, txHash)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/merchants", wrapper.GetAllMerchants)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/merchants/{merchantCode}", wrapper.GetMerchant)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/merchants/{merchantCode}/transactions", wrapper.GetTransactionsByMerchant)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/networks", wrapper.GetAllNetworks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/networks/{networkCode}/tokens", wrapper.GetAllTokens)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/networks/{networkCode}/transactions/{txHash}", wrapper.GetSubmission)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/networks/{networkCode}/transactions/{txHash}", wrapper.SubmitPaymentTransaction)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAD//1GoaiQWLgAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

